### `VFS`

在Red Hat操作系统中，VFS代表的是"Virtual File System"，即虚拟文件系统。VFS是一个抽象层，它提供了对底层文件系统的统一访问接口，使得不同类型的文件系统可以被统一管理和访问。通过VFS，应用程序可以使用相同的系统调用来处理不同类型的文件系统，而无需了解底层文件系统的细节。这种抽象层的存在使得操作系统更加灵活和可扩展，因为可以方便地添加新的文件系统类型而无需修改应用程序的代码。

### Volume Manager

Volume Manager（卷管理器）是一种软件工具或服务，用于管理存储卷和卷组。它的作用是管理存储设备、分配存储空间、创建卷组和逻辑卷、以及提供高级的数据管理功能。

在Linux系统中，逻辑卷管理（Logical Volume Management，LVM）是一种常见的卷管理器。LVM允许管理员将多个物理存储设备组合成卷组，从中创建逻辑卷，并且可以动态地调整逻辑卷的大小。此外，LVM还支持数据快照、磁盘扩展、数据迁移等高级功能，使得存储管理更加灵活和可靠。



### DPDK

在Red Hat中，DPDK是指Data Plane Development Kit，是一种用于加速数据包处理的开源工具集。DPDK旨在提供高性能、低延迟的数据包处理，通常用于构建高性能网络应用程序和解决方案，例如网络功能虚拟化（NFV）、软件定义网络（SDN）等。DPDK提供了一组用户空间的库和驱动程序，允许开发人员通过绕过操作系统内核直接访问网络设备硬件，从而实现更快的数据包处理速度和更低的延迟。在Red Hat中，DPDK通常与其他技术一起使用，例如Open vSwitch（OVS）等，以实现网络功能虚拟化和软件定义网络等方案。

磁盘 —> cpu缓存

### 性能优化常用目录

```bash
/proc 
# 虚拟目录、/proc/meminfo、 /proc/cpuinfo
# /proc 动态
# /sys 静态

ps、top 、vmstat 、lscpu、lspci、lsusb
ping 、traceroute、ethtool、route

strace、 ltrace、ldd

sar、perf、memleak

wireshark、tcpdump

DPDK、BPF、tuned
```



```bash
lscpu

[luohao@localhost ~]$ lscpu
Architecture:        x86_64
CPU op-mode(s):      32-bit, 64-bit
Byte Order:          Little Endian
CPU(s):              1
On-line CPU(s) list: 0
Thread(s) per core:  1
Core(s) per socket:  1
Socket(s):           1
NUMA node(s):        1
Vendor ID:           GenuineIntel
CPU family:          6
Model:               142
Model name:          Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz
Stepping:            10
CPU MHz:             1991.999
BogoMIPS:            3983.99
Hypervisor vendor:   VMware
Virtualization type: full
L1d cache:           32K
L1i cache:           32K
L2 cache:            256K
L3 cache:            8192K
NUMA node0 CPU(s):   0
Flags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon nopl xtopology tsc_reliable nonstop_tsc cpuid pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault invpcid_single pti ssbd ibrs ibpb stibp fsgsbase tsc_adjust bmi1 avx2 smep bmi2 invpcid rdseed adx smap clflushopt xsaveopt xsavec xgetbv1 xsaves arat md_clear flush_l1d arch_capabilities

```



```

[luohao@localhost ~]$ cat /proc/cpuinfo 
processor	: 0
vendor_id	: GenuineIntel
cpu family	: 6
model		: 142
model name	: Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz
stepping	: 10
microcode	: 0xb4
cpu MHz		: 1991.999
cache size	: 8192 KB
physical id	: 0
siblings	: 1
core id		: 0
cpu cores	: 1
apicid		: 0
initial apicid	: 0
fpu		: yes
fpu_exception	: yes
cpuid level	: 22
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon nopl xtopology tsc_reliable nonstop_tsc cpuid pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault invpcid_single pti ssbd ibrs ibpb stibp fsgsbase tsc_adjust bmi1 avx2 smep bmi2 invpcid rdseed adx smap clflushopt xsaveopt xsavec xgetbv1 xsaves arat md_clear flush_l1d arch_capabilities
bugs		: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit srbds mmio_stale_data retbleed gds
bogomips	: 3983.99
clflush size	: 64
cache_alignment	: 64
address sizes	: 45 bits physical, 48 bits virtual
power management:

```



```
DSCP        # 软件队列
```



```
FIFO          # 硬件队列
```



### 监视中断

```bash
watch -n .1 -d   cat /proc/interrupts
            CPU0

# 硬件中断不可逆，软件可逆
```

### CPU平均负载





### CPU使用率

> CPU使用率是单位时间内CPU繁忙情况的统计，跟平均负载不一定完全对应



```bash


```



### 报告进程的状态

```bash

```



### io查看

```
iostat
```

### top 的`s`字段


在 `top` 命令中，字段 `S` 表示进程的状态，与在进程列表中的状态相同。在 `top` 中，常见的状态标识如下：

- `R`：正在运行，进程正在执行或准备执行。
- `S`：睡眠状态，进程正在等待某些事件的发生，比如等待 I/O 完成。
- `D`：不可中断的睡眠状态，进程正在等待一个不可中断的事件，通常是等待磁盘 I/O 完成。
- `T`：已停止，进程被停止或接收到了一个信号。
- `Z`：僵尸状态，进程已经终止，但其父进程尚未调用 `wait()` 或 `waitpid()` 函数来获取其终止状态。

### 进程和线程

在 Red Hat 系统中，进程（Process）和线程（Thread）的理解与一般的操作系统相同，但是在实际应用中有一些特定的使用方式和注意事项。

1. **进程（Process）**：

   - 在 Red Hat 系统中，进程是程序执行的一个实例。每个进程都有自己独立的地址空间、内存、文件描述符等系统资源。

   - 进程可以被视为运行中的程序的一个实例。当您在 Red Hat 系统上启动一个程序时，操作系统会为该程序创建一个新的进程。
   - 进程之间通常是相互独立的，它们不能直接访问彼此的内存空间。进程间通信（Inter-Process Communication，IPC）通常需要使用特定的机制，如管道、消息队列、共享内存等。
   - 在 Red Hat 系统中，您可以使用命令如 `ps`、`top` 等来查看当前正在运行的进程。

2. **线程（Thread）**：
   - 线程是进程内的执行单元。在一个进程中可以包含多个线程，它们共享相同的地址空间和其他资源。
   - 与进程不同，线程之间的通信和数据共享相对容易，因为它们可以直接访问同一进程的内存空间。
   - 线程共享进程的资源，如打开的文件描述符、信号处理器等。这意味着在创建线程时的开销比创建进程要小。
   - 在 Red Hat 系统中，您可以使用线程来实现并行计算、多任务处理等，通常使用线程库（如 POSIX 线程库）来管理线程。

总的来说，进程和线程在 Red Hat 系统中的概念与其他操作系统类似，但在实际应用中可能会有一些特定的使用方式和注意事项，例如使用特定的系统调用、库函数等来创建和管理进程和线程。

### CPU上下文切换

> CPU寄存器是CPU内置的容量小、但速度极快的内存。（环境）
>
> 程序计数器是用来存储CPU正在执行的指令位置、或者即将执行的下一条指令位置。（指令)
>
>  CPU寄存器和程序计数器都是CPU 。在运行任何任务前，必须的依赖环境，因此被叫做CPU上下文

#### 上下文切换分类

1. 程上下文切换
2. 线程上下文切换
3. 中断上下文切换

> 任务就是进程 -> 分配资源单位
>
> 任务就是线程 -> CPU调用单位



`user`    — `systemcore`  — `kernel`

1. `user`不能直接访问`kernel`。
2. `systemcore`是桥梁；

### 进程上下文切换

> Linux按照特权等级，把进程的运行空间分为内核空间和用户空间CPU特权等级的`Ring0`和`Ring3`

1. 内核空间（Ring 0）具有最高权限(特权指令)，可以直接访问所有资源;
2. 用户空间（Ring 3）只能访问受限资源(非特权指令），不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。

`kernel + vm`  打包  ->  `EXSI`

### `VHW`

>  在 Red Hat 虚拟化中，VHW 代表的是 Virtual Hardware，即虚拟硬件。在虚拟化环境中，虚拟硬件模拟了物理计算机上的各种硬件设备，如虚拟 CPU、虚拟内存、虚拟网络适配器、虚拟磁盘等。
>
> Red Hat 虚拟化平台通常使用的是 KVM（Kernel-based Virtual Machine）作为虚拟化技术，它允许将 Linux 内核转变为一个 Hypervisor，并利用该 Hypervisor 在同一台物理服务器上运行多个虚拟机。在这种虚拟化环境中，每个虚拟机都会被分配一套虚拟硬件，这些虚拟硬件由 Hypervisor 模拟并提供给虚拟机使用。
>
> VHW 可以包括诸如虚拟 CPU 核心数、虚拟内存大小、虚拟网络适配器型号、虚拟磁盘控制器类型等。管理者可以根据实际需求对虚拟硬件进行配置和调整，以满足虚拟机工作负载的需求，例如提高虚拟机的性能、扩展虚拟机的存储容量等。

### 进程运行



`pagesize` 4096(通常的操作系统page 的大小)

block4k -> 1 page

`MMU `内存管理单元

### CPU优先级

> system Priority : 0~139。优先级降低
>
> real-time-Priority:0~99     # 不可调
>
> real-time-Priority + nice level = system Priority

只能通过调整nice level ：

nice 和renice

### 查看上下文切换情况

```bash
vmstat

vmstat是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析
CPU 上下文切换和中断的次数
– cs（context switch）是每秒上下文切换的次数
– in（interrupt）则是每秒中断的次数
– r（Running or Runnable）是就绪队列的长度，正在运行和等待CPU 的进程数
– b（Blocked）则是处于不可中断睡眠状态的进程数
```

### 自愿和非自愿切换

```bash
cswch     # 自愿
nvcswch     # 非自愿
```

## 内存优化

只有内核才可以操作物理内存。程序只能操作虚拟内存

### 虚拟地址空间

> 虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同字长（也就是单个CPU指令
> 可以处理数据的最大长度）的处理器，地址空间的范围也不同。比如最常见的32 位和64
> 位系统

```bash
cat /proc/meminfo | grep -i page
 # 查看页
 
 x86info
```

### 虚拟内存空间分布

1. 只读段：包括代码和常量等
2. 数据段：包括全局变量等
3. 堆：包括动态分配的内存，从低地址开始向上增长
4. 文件映射段：包括动态库、共享内存等，从高地址开始
   向下增长；（`dll`，`ko`）
5. 栈：包括局部变量和函数调用的上下文等。栈的大小是
   固定的，一般是`8MB`

### 内存分配与回收

malloc() 是C标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即brk()和
mmap()
– 对小块内存（小于128K），C 标准库使用brk() 来分配
• brk() 方式的缓存，可以减少缺页异常的发生，提高内存访问效率。由于这些内存没有归还系统，在内
存工作繁忙时，频繁的内存分配和释放会造成内存碎片
– 大块内存（大于128K），使用内存映射mmap() 来分配
• mmap() 方式分配的内存，会在释放时直接归还系统，所以每次mmap都会发生缺页异常。在内存工作
繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大;

系统不会任由某个进程用完所有内存。在发现内存紧张时，系统就会通过一系列机制来回收
内存
– 回收缓存，使用LRU算法，回收最近使用最少的内存页面
– 回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中
– 杀死进程，内存紧张时系统还会通过OOM，直接杀掉占用大量内存的进程

### swap 优化方法

l 通常只在内存不足时，才会发生Swap交换。并且由于磁盘读写的速度远比内存慢，Swap 会
导致严重的内存性能问题
l 优化方法
– 使用多块不同的物理磁盘作为SWAP分区，增加换入换出的I/O吞吐量
– 在SWAP分区上实现不同的优先级

### OOM优化方法

`OOM（Out of Memory）`，其实是内核的一种保护机制。它监控进程的内存使用情况，并且使用`oom_score`为每个进程的内存使用情况进行评

- 一个进程消耗的内存越大，`oom_score` 就越大
- 一个进程运行占用的CPU越多，`oom_score` 就越小

进程的`oom_score`越大，代表消耗的内存越多，越容易被OOM杀死，从而可以更好保护系
统

- oom_adj的范围是[-17, 15]，数值越大，表示进程越容易被OOM杀死；数值越小，表示进程越不容易被OOM杀死，其中-17表示禁止OOM
- echo -16 > /proc/$(pidof sshd)/oom_adj

### 查看内存使用情况

```bash
free
# total 是总内存大小
# used 是已使用内存的大小，包含了共享内存
# free 是未使用内存的大小
# shared 是共享内存的大小
# buff/cache 是缓存和缓冲区的大小
# available 是新进程可用内存的大小

top
# VIRT是进程虚拟内存大小，只要是进程申请过的内存，即便没有真正分配物理内存，也会计算在内
# RES是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括Swap和共享内存
# SHR是共享内存的大小，与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等
# %MEM 是进程使用物理内存占系统总内存的百分比
```

### buffer和cache

- Buffers是内核缓冲区用到的内存，对应的是`/proc/meminfo`中的Buffers值
- Cache是内核页缓存和Slab用到的内存，对应的是`/proc/meminfo`中的Cached与
  SReclaimable之和

### proc文件系统

/proc是Linux内核提供的一种特殊文件系统，是用户跟内核交互的接口, 用户可以从/proc中，查询内核的运行状态和配置选项。查询进程的运行状态、统计数据等，也可以通过/proc来修改内核的配置

- Buffers是对原始磁盘块的临时存储，用来缓存磁盘的数据，通常不会特别大（20MB 左右）。内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写合并成单次大的写等等--------写
- Cached是从磁盘读取文件的页缓存，也就是用来缓存从文件读取的数据。下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘--------读
- SReclaimable是Slab的一部分。Slab包括两部分，其中的可回收部分，用SReclaimable记录；
  而不可回收部分，用SUnreclaim记录

### proc



```bash



```



### 判断内存是否泄露

```free - m 
# 方法一：
free -m # 查看剩余内存
kill -9 # 杀死进程
free -m # 再看内存是否回收

# 方法二：
memleak
```

## 补充命令

### 查看虚拟机

```bash
vmctl status all
```

### 查看`cpu`负载

```bash
uptime
# 当前时间：显示系统当前时间。

# 系统已运行时间：显示系统自上次启动以来已经运行的时间。格式为天数、小时和分钟。

# 当前用户数：显示当前登录系统的用户数量。

# 系统的平均负载：平均负载是系统处于运行状态的一段时间内正在使用或者等待处理的任务数量。它是一个三个数值的指标，分别代表了过去1分钟、5分钟和15分钟内的平均负载
```

### 监控

```bash
watch -n 1 uptime

# 例如：
watch -n -d 1 uptime
# -n 后面可以跟一个整数值，表示 watch 命令执行命令的时间间隔，单位为秒。
# -d 参数表示⾼亮显示变化的区域

mpstat -P ALL 5  # -P ALL 表示监控所有CPU，后⾯数字5表示间隔5秒后输出⼀组数据

```

### 查看CPU信息

```bash
# 方法一
lscpu

[luohao@localhost ~]$ lscpu
Architecture:        x86_64
CPU op-mode(s):      32-bit, 64-bit
Byte Order:          Little Endian
CPU(s):              1
On-line CPU(s) list: 0
Thread(s) per core:  1
Core(s) per socket:  1
Socket(s):           1
NUMA node(s):        1
Vendor ID:           GenuineIntel
CPU family:          6
Model:               142
Model name:          Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz
Stepping:            10
CPU MHz:             1991.999
BogoMIPS:            3983.99
Hypervisor vendor:   VMware
Virtualization type: full
L1d cache:           32K
L1i cache:           32K
L2 cache:            256K
L3 cache:            8192K
NUMA node0 CPU(s):   0
Flags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon nopl xtopology tsc_reliable nonstop_tsc cpuid pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault invpcid_single pti ssbd ibrs ibpb stibp fsgsbase tsc_adjust bmi1 avx2 smep bmi2 invpcid rdseed adx smap clflushopt xsaveopt xsavec xgetbv1 xsaves arat md_clear flush_l1d arch_capabilities

# 方法二
cat /proc/cpuinfo 

```

### 查看CPU使用信息

```bash
mpstat     # 报告CPU的状态 Report processors related statistics.
mpstat -P all 5 # 5秒钟采集一次

# 时间戳（Timestamp）：这个字段显示了报告的时间戳，表示 mpstat 命令执行时的时间。
# CPU编号（CPU ID）：这个字段显示了每个 CPU 的编号，从0开始递增。
# 用户态使用率（%usr）：这个字段表示 CPU 在用户态（用户程序）下的使用率。它包括用户程序执行时间、用户空间中的系统调用和软中断处理时间。
# 系统态使用率（%sys）：这个字段表示 CPU 在系统态（内核）下的使用率。它包括内核中运行的系统进程和内核处理中的软中断时间。
# 空闲态使用率（%idle）：这个字段表示 CPU 处于空闲状态的时间比例。当 CPU 没有执行任何任务时，它处于空闲状态。
# 等待 I/O 使用率（%iowait）：这个字段表示 CPU 等待 I/O 操作完成的时间比例。当 CPU 在等待硬盘 I/O 或其他 I/O 操作时，它会处于等待状态。
# 硬中断使用率（%irq）：这个字段表示 CPU 在处理硬中断的时间比例。硬中断是由外部设备（如网卡、磁盘控制器等）发送给 CPU 的中断信号。
# 软中断使用率（%soft）：这个字段表示 CPU 在处理软中断的时间比例。软中断是由内核产生的、与硬件无关的中断，用于执行特定的任务。
# 虚拟化失真使用率（%steal）：这个字段表示 CPU 在被其他虚拟机或虚拟化宿主系统（如KVM、Xen等）“偷取”（steal）的时间比例。当虚拟机竞争CPU资源时，这个指标会增加。
# Guest使用率（%guest）：这个字段表示 CPU 在虚拟化环境中运行虚拟机的时间比例。
# Guest Nice使用率（%gnice）：这个字段表示虚拟机在用户态执行的优先级较低的时间比例。
```

### 查看进程和线程

```bash
pidstat -u 5 1 # 该命令的作用是每隔 5 秒显示一次 CPU 使用情况，并且仅显示一次（共显示一次）。这个命令用于查看当前系统中所有进程的 CPU 使用情况。
Linux 4.18.0-513.18.1.el8_9.x86_64 (localhost.localdomain) 	03/18/2024 	_x86_64_	(1 CPU)

11:16:47 AM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
11:16:52 AM     0      1123    0.20    0.00    0.00    0.00    0.20     0  tuned
11:16:52 AM  1000      2731    0.60    1.00    0.00    0.40    1.59     0  gnome-shell
11:16:52 AM  1000      3868    0.40    0.00    0.00    0.20    0.40     0  gnome-terminal-
11:16:52 AM  1000     41005    0.00    0.20    0.00    0.00    0.20     0  pidstat

# uid 等于 0是 root
```





